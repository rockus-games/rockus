# Поиск минимума функции: градиентный спуск
# В математике и машинном обучении часто возникает задача поиска минимума функции, то есть нахождения точки,
# в которой функция достигает своего минимального значения. Одним из методов решения этой задачи является градиентный спуск. 
# Градиентный спуск — это метод оптимизации функции, при котором на каждом шаге происходит движение в направлении наиболее
#  быстрого убывания функции. Данный метод позволяет итеративно улучшать приближение к минимуму функции. По сути, он построен
#  на нахождении значения производной.
# Градиентный спуск используется во многих задачах машинного обучения, таких как линейная регрессия, логистическая регрессия,
#  нейронные сети и другие. Знание этого метода является важным для понимания работы этих методов машинного обучения. 
import numpy as np

# Определяем функцию
def f(x):
    return x**2 + 10*np.sin(x)

# Определяем производную функции
def grad_f(x):
    return 2*x + 10*np.cos(x)

# Определяем функцию градиентного спуска
def gradient_descent(start, learning_rate, n_iterations):
    x = start
    trajectory = [x]
    for i in range(n_iterations):
        x = x - learning_rate * grad_f(x)
        trajectory.append(x)
    return np.array(trajectory)

# Начальная точка
start = -5

# Скорость обучения
learning_rate = 0.1

# Число итераций
n_iterations = 100

# Запускаем градиентный спуск
trajectory = gradient_descent(start, learning_rate, n_iterations)

# Выводим результаты
print("Minimum point:", trajectory[-1])
print("Function value at the minimum point:", f(trajectory[-1]))

#В этом примере мы определяем функцию «f(x)» и её производную «grad_f(x)». Затем мы определяем функцию «gradient_descent», которая использует производную для нахождения оптимальной точки. Мы задаём начальную точку, скорость обучения и число итераций и запускаем градиентный спуск. Затем мы выводим результаты: точку минимума и значение функции в этой точке.
#Визуализируем результат:
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-10, 10, 1000)
y = x**2 + 10*np.sin(x)

plt.plot(x, y)
plt.scatter(trajectory[-1], f(trajectory[-1]))
plt.xlabel('x')
plt.ylabel('y')
plt.title('График функции x^2 + 10*sin(x)')
plt.show()



# Чтобы построить график, нужно задать интервал значений x и вычислить соответствующие значения y,
#  используя заданную функцию. Здесь мы используем функцию «linspace()» из библиотеки «numpy»,
#  чтобы создать массив значений x на интервале от -10 до 10 с 1000 равномерно расположенными значениями.
#  Затем мы вычисляем значения y для каждого значения x, используя заданную функцию. И, наконец,
#  мы строим график функции, задавая массивы x и y в качестве аргументов функции «plot()».
#  Далее мы добавляем подписи осей и заголовок графика с помощью функций «xlabel()»,
#  «ylabel()» и «title()». Наконец, мы вызываем функцию «show()» для отображения графика.
# Найденную оптимальную точку мы тоже отмечаем на графике. Для этого используем функцию «scatter».
# Как видим, минимум функции был успешно найден.